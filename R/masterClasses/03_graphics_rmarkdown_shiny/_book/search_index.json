[
["index.html", "Gráficos con R Preámbulo", " Gráficos con R Olivier Nuñez 2018-02-06 Preámbulo “Una imagen vale más que mil palabras” (“Un bon croquis vaut mieux qu’un long discours”) — Napoleon La representación gráfica de los datos es una potente herramienta de síntesis de la información estadística. Cualquiera que sea la etapa de su trabajo (exploración, modelización, confirmación o comunicación de resultados), el usuario de métodos estadísticos encuentra en los gráficos un aliado para ahorrar tiempo. El objetivo de esta sessión es manejar las herramientas del entorno R que permiten el diseño de los principales gráficos utilizados en el análisis de datos (diagramas, curvas, mapas, grafos). Se abordarán los distintos pasos de la elaboración de un gráfico, que van desde la preparación de los datos, hasta su exportación. La estructura del curso consiste en dos partes. La primera parte estará dedicada a la elaboración de las representaciones gráficas más utilizadas en estadística. En la segunda parte, se tratarán aspectos avanzados en la confección del gráfico, como el diseño de ejes y leyendas, la superposición de puntos, el solapamiento de etiquetas o la elección de escalas de colores. En la proxima sessión, se presentarán las herramientas para insertar esta información gráfica en informes estáticos, automatizados o dinámicos. "],
["graficos-basicos.html", "1 Gráficos básicos 1.1 Gráficos de dispersión 1.2 Gráficos de barra 1.3 Histogramas 1.4 Diagramas de caja (boxplots) 1.5 Expotación de los graficos", " 1 Gráficos básicos Esta sección es una rapida introducción a los gráficos básicos en R. Estos gráficos sirven esencialmente para examinar de manera visual y rápida conjuntos de datos. Vamos a examinar los más habituales. Existen, sin embargo, muchos tipos más y hay libros enteros dedicados a ellos. 1.1 Gráficos de dispersión Los gráficos de dispersión muestran la relación entre dos variables numéricas. En el ejemplo siguiente serán la velocidad y la distancia de frenado de un conjunto de coches recogidas en el conjunto de datos cars: plot(speed~dist,data=cars) La notación y ~ x es muy común en R y significa que se hace algo con y en función de x; en este caso, ese “algo”&quot; es un grafico de y respecto a x. En los modelos de regresión, donde se pretende explicar las variaciones de y mediante las de x, se hará también uso de esta notación. Los gráficos admiten opciones y elementos adicionales que van añadiéndose progresivamente al lienzo: plot(speed~dist,data=cars, ylab=&quot;Velocidad (milla por hora)&quot;,xlab=&quot;Distancia (pies)&quot;) abline(lm(speed~dist,data=cars)) grid() Consulta ?par, una página de ayuda en R que muestra gran cantidad de parámetros modificables en un gráfico. &gt; Investiga y usa col, lty y lwd. Nota: casi nadie conoce estos parámetros y, menos, de memoria; pero está bien saber que existen por si un día procede utilizarlos. Lo anterior, se puede generalizar al análisis de más de dos variables mediante la función pairs(): names(trees)&lt;-c(&quot;Diametro&quot;,&quot;Altura&quot;,&quot;Volumen&quot;) pairs(trees, panel = panel.smooth, main = &quot;Medidas de 31 arboles&quot;) 1.2 Gráficos de barra Los gráficos de barras muestran los valores de un vector, típicamente construido como el promedio de una serie de variables numéricas o el conteo de unas categóricas. Utilizamos la base de datos VADeaths que proporciona las tasas de mortalidad en Virginia por grupos socio-demograficos: Rural Male Rural Female Urban Male Urban Female 50-54 11.7 8.7 15.4 8.4 55-59 18.1 11.7 24.3 13.6 60-64 26.9 20.3 37.0 19.3 65-69 41.0 30.9 54.6 35.1 70-74 66.0 54.3 71.1 50.0 barplot(VADeaths[, 2], xlab = &quot;Tramos de edad&quot;, ylab = &quot;Tasa de mortalidad (por 1000 mujeres)&quot;, main = &quot;Tasa de mortalidad en Virginia \\n (mujeres en ambito rural, 1940)&quot;) Los gráficos de puntos son alternativas recomendadas a las tradicionales barras: dotchart(t(VADeaths), main = &quot;Tasa de mortalidad (por 1000 hab.), Virginia (1940)&quot;, cex = 0.8) Mejorar el gráfico de barra siguiente con los parámetro col (de color), horiz(de horizontal) e ylog (escala log). Aplicar dotchart a las superficies ordenadas. barplot(islands, main = &quot;Superficie de las islas más grandes (en millas cuadradas&quot;) 1.3 Histogramas El histograma es una representación gráfica de la distribución de una variable númerica que permite hacerse una rapida idea de como se distribuyen los datos en la recta real (p.e., las alturas de un conjunto de personas). require(MASS) #para cargar el conjunto de datos survey names(survey) ## [1] &quot;Sex&quot; &quot;Wr.Hnd&quot; &quot;NW.Hnd&quot; &quot;W.Hnd&quot; &quot;Fold&quot; &quot;Pulse&quot; &quot;Clap&quot; ## [8] &quot;Exer&quot; &quot;Smoke&quot; &quot;Height&quot; &quot;M.I&quot; &quot;Age&quot; alturas=na.omit(survey$Height) hist(alturas,labels=TRUE,las=1,ylim=c(0,50),main=&quot;Altura de estudiantes de la Universidad de Adelaide&quot;) El número de barra es arbitrario y puede distorsionar nuestra idea de la distribución: hist(alturas,breaks=20,proba = TRUE,col=&quot;lightblue&quot;,border=&quot;blue4&quot;) Ajuste con una distribución normal (¡malo!): hist(alturas,breaks=20,proba = TRUE,col=&quot;lightblue&quot;,border=&quot;blue4&quot;,main=&quot;Ajuste con la normal&quot;) m=mean(alturas);s=sd(alturas) x=seq(min(alturas),max(alturas),.1) p=dnorm(x,m,s) lines(x,p,col=&quot;red&quot;) Estudiar la distribución del pulso de estos alumnos. Usar col para mejorar el aspecto del gráfico. Añádir un título y una etiqueta en el eje horizontal. Usar la función abline para dibujar una línea vertical roja en la media de la distribución. 1.4 Diagramas de caja (boxplots) Los diagramas de caja son parecidos a los histogramas porque resumen la distribución de una variable continua (mediante una caja y unos segmentos que acotan las regiones donde la variable tiene el grueso de las observaciones). La representación es menos fina que la del histograma pero es más robusta (menos sensible a valores extremos). boxplot(survey$Height, col = &quot;gray&quot;,main = &quot;Altura de los estudiantes&quot;) rug(survey$Height, side = 2) boxplot(Height ~ Sex, data=survey, notch=TRUE, col = &quot;gray&quot;,main = &quot;Altura según sexo&quot;) Estudiar la distribución del pulso según el sexo mediante la función boxplot. 1.5 Expotación de los graficos Los graficos se pueden exportar en diversos formatos: Imagen tipo bitmap (jpeg(),png(),bmp(),tiff(),…) Imagen vectorial (pdf(),svg(),…) Para más información consultar la ayuda ?Devices Ejemplo de uso: pdf(&quot;mifichero.pdf&quot;) boxplot(Height ~ Sex, data=survey, notch=TRUE, col = &quot;gray&quot;,main = &quot;Altura según sexo&quot;) dev.off() png(&quot;mifichero.png&quot;) boxplot(Height ~ Sex, data=survey, notch=TRUE, col = &quot;gray&quot;,main = &quot;Altura según sexo&quot;) dev.off() Guarda el graficos en formato pdf y png en ficheros del directorio de trabajo Las imagenes vectoriales tienen una resolución “infinita”&quot; y ocupan poca memoria. Sin embargo, no todos los editores de texto admiten este tipo de formato. "],
["graficos-avanzados-con-ggplot2.html", "2 Gráficos avanzados (con ggplot2) 2.1 Elementos de un gráfico en ggplot2 2.2 Introducción a ggmap 2.3 Extensión dinamica de los graficos", " 2 Gráficos avanzados (con ggplot2) Funciones de R tales como plot, hist, barplot, boxplot y otras se apoyan en el motor gráfico tradicional de R, que es suficiente para esos fines. Sin embargo, se queda corto para construir otro tipo de gráficos más avanzados. Por eso, en 2001, Paul Murrell desarrolló un motor gráfico alternativo, grid que facilita la generación en R de varias capas y de Trellis (o pequeños múltiplos). Los gráficos de Trellis permiten seguir el comportamiento de unas variables de interés a través de los distintos niveles de otras, disponiendo la información en una retícula que facilita el descubrimiento de patrones por inspección visual. El gráfico siguiente muestra la evolución de la tasa de paro según la provincia y el sexo. Hay muchas funciones y paquetes que crean gráficos apoyándose en el motor gráfico grid. El más popular. es ggplot2. Es una implementación de las ideas recogidas en el artículo de The Language of Graphics escrito por Leland Wilkinson y sus coautores en 2000. De este lenguaje, implementado en el paquete ggplot2, se ocupan las siguientes secciones. 2.1 Elementos de un gráfico en ggplot2 El grafico anterior, se obtuvo de la siguiente manera. En primer lugar, se carga el paquete ggplot2 y los datos del paro: require(ggplot2) #carga el paquete ggplot2 paro &lt;- read.csv(&quot;data/paro_final.csv&quot;,encoding=&quot;UTF-8&quot;) #carga los datos head(paro) ## Year Cuat tasa.paro Genero prov Provincias ## 1 2011 1 10.792350 Mujeres 1 Araba/Álava ## 2 2011 2 9.348442 Mujeres 1 Araba/Álava ## 3 2011 3 10.953058 Mujeres 1 Araba/Álava ## 4 2011 4 12.916667 Mujeres 1 Araba/Álava ## 5 2012 1 16.258993 Mujeres 1 Araba/Álava ## 6 2012 2 14.742698 Mujeres 1 Araba/Álava La expresión de ggplot2 para crear el gráfico anterior fue: ggplot(paro) + aes(x = Year, y = tasa.paro, col = Genero) + geom_point() + geom_smooth(alpha = 0.5,se = FALSE) + facet_wrap( ~ Provincias) Esta expresión combina varios elementos que discutiremos con detalle más adelante: Datos: siempre una tabla (data.frame) Estéticas: elementos representables gráficamente (la posición x e y, el color, …) en columnas del data.frame. Geometrías (o capas): puntos, rectas, histogramas, densidades, etc. También se llaman capas porque pueden superponerse. Facetas: parten un gráfico en sublienzos preservando las escalas (pequeños múltiplos) 2.1.1 Datos Uno de los elementos más importantes de un gráfico son los datos que se quieren representar. Una particularidad de ggplot2 es que solo acepta un tipo de datos: data.frames. Otras funciones gráficas (p.e., hist) admiten vectores, listas u otro tipo de estructuras. ggplot2 no. Por otro lado, es preferible que los datos estén en un formato “largo” (long format), es decir, una columna para cada dimensión y una fila para cada observación. p &lt;- ggplot(iris) El código anterior crea un objeto, p que viene a ser un proto-gráfico: contiene los datos que vamos a utilizar, los del conjunto de datos iris. Obviamente, el código anterior es insuficiente para crear un gráfico: aún no hemos indicado qué queremos hacer con iris. 2.1.2 Estéticas (aes) En un conjunto de datos hay columnas: edad, altura, ingresos, temperatura, etc. En un gráfico hay, en la terminología de ggplot2, aesthetic. Estéticas son, por ejemplo, la distancia horizontal o vertical, el color, la forma (de un punto), el tamaño (de un punto o el grosor de una línea), etc. p &lt;- p + aes(x = Petal.Length, y = Petal.Width, colour = Species) se están añadiendo a p información sobre las estéticas que tiene que utilizar y qué variables de iris tiene que utilizar: La distancia horizontal, x, vendrá dada por la longitud del pétalo. La distancia vertical, y, por su anchura. El color, por la especie. Al protográfico se le han sumado las estéticas. En las secciones siguientes se le sumarán otros elementos adicionales. Lo importante es recordar cómo la suma es el signo que combina los elementos que componen el lenguaje de los gráficos. De todos modos, es habitual combinar ambos pasos en una única expresión p &lt;- ggplot(iris, aes(x = Petal.Length, y = Petal.Width, colour = Species)) El objeto p resultante aún no es un gráfico ni se puede representar. Le faltan capas, que es el objeto de la siguiente sección. No obstante, se puede inspeccionar así: summary(p) ## data: Sepal.Length, Sepal.Width, Petal.Length, Petal.Width, ## Species [150x5] ## mapping: x = Petal.Length, y = Petal.Width, colour = Species ## faceting: &lt;ggproto object: Class FacetNull, Facet, gg&gt; ## compute_layout: function ## draw_back: function ## draw_front: function ## draw_labels: function ## draw_panels: function ## finish_data: function ## init_scales: function ## map_data: function ## params: list ## setup_data: function ## setup_params: function ## shrink: TRUE ## train_scales: function ## vars: function ## super: &lt;ggproto object: Class FacetNull, Facet, gg&gt; Ahí están indicados los datos que va a utilizar y la relación (o mapeo) entre estéticas y columnas de los datos. ¿Cuántas estéticas existen? Alrededor de una docena, aunque se utilizan, generalmente, menos: x e y, distancias horizontal y vertical. colour, para el color. size, para el tamaño. shape, que indica la forma de los puntos (cuadrados, triángulos, etc.) de los puntos o del trazo (continuo, punteado) de las líneas. alpha para la transparencia: los valores más altos tendrían formas opacas y los más bajos, casi transparentes. También uuy útil para el solapamiento de puntos. fill, para el color de relleno de las formas sólidas (barras, etc.). Hay que advertir que no todas las estéticas tienen la misma potencia en un gráfico. El ojo humano percibe fácilmente longitudes distintas. Pero tiene problemas para comparar áreas (que es lo que regula la estética size) o intensidades de color. Se recomienda usar las estéticas más potentes para representar las variables más importantes. 2.1.3 Capas (geoms) Las capas (o geoms para ggplot2) son los verbos del lenguaje de los gráficos. Indican qué hacer con los datos y las estéticas elegidas, cómo representarlos en un lienzo: p &lt;- p + geom_point() p Una vez añadida una capa al gráfico, este puede pintarse (que es lo que ocurre al llamar a p). Se obtiene el mismo resultado haciendo, en una única línea, ggplot(iris, aes(x = Petal.Length, y = Petal.Width, colour = Species)) + geom_point() Una característica de las capas, y de ahí su nombre, es que pueden superponerse. Por ejemplo, ggplot(iris, aes(x = Petal.Length, y = Petal.Width, colour = Species)) + geom_point() + geom_smooth() añade al gráfico una curva suavizada (con sus intervalos de confianza en gris). Existen muchos tipos de capas. Los más usuales son geom_point, geom_line, geom_histogram, geom_bar y geom_boxplot (ver las página http://docs.ggplot2.org/current/) para una lista actualizada. Elaborar el siguientes gráfico sobre la evolución del paro en España. Utilizar la capa geom_jitter y la estética alpha para subsanar problemas de solapamiento. 2.1.4 Facetas Muchos de los gráficos anteriores pueden ser reproducidos sin mucho esfuerzo (exceptuando, tal vez, cuestiones de aspecto) usando los gráficos tradicionales de R, pero no los que usan facetas. Las facetas implementan los gráficos de Trellis mencionados antes. Por ejemplo, ggplot(iris, aes(x = Petal.Length, y = Petal.Width)) + geom_point() + geom_smooth() + facet_grid(~ Species) crea tres gráficos dispuestos horizontalmente que comparan la relación entre la anchura y la longitud del pétalo de las tres especies de iris. Una característica de estos gráficos, que es crítica para poder hacer comparaciones adecuadas, es que comparten ejes. Los gráficos podrían disponerse verticalmente reemplazando facet_grid(~ Species) por facet_grid(Species ~ .) en el código anterior. Además, se puede subdividir el lienzo por dos (¡o más!) variables así: paro$Cuat&lt;-factor(paro$Cuat,levels=1:4,labels=c(&quot;I&quot;,&quot;II&quot;,&quot;III&quot;,&quot;IV&quot;),ordered=TRUE) #cuatrimestre en notación romana tmp &lt;- subset(paro, Provincias %in% c(&quot;Zaragoza&quot;, &quot;Huesca&quot;, &quot;Teruel&quot;)) ggplot(tmp, aes(x = Year, y = tasa.paro, color=Genero)) + geom_point() + geom_line() + facet_grid(Provincias~Cuat) En caso de haber muchas categorías (p.e., provincia), puede usarse la función facet_wrap para distribuir las subgráficas en una cuadrícula. Elaborar los siguientes gráfico sobre la distribución del paro en España. 2.1.5 Toque final y exportación 2.1.5.1 Etiquetas Las estéticas se pueden etiquetar con la función labs. Además, se le puede añadir un título al gráfico usando la función ggtitle. Por ejemplo, en el gráfico anterior se pueden reetiquetar los ejes y la leyenda haciendo p &lt;- p + ggtitle(&quot;Anchura y longitud de pétalos de tres especies de iris&quot;) + labs(x = &quot;Longitud&quot;, y = &quot;Anchura&quot;, colour = &quot;Especie&quot;) 2.1.5.2 Temas Los temas de ggplot2 permiten modificar aspectos estéticos del gráfico que no tienen que ver con los datos en sí. Eso incluye los ejes, etiquetas, colores de fondo, el tamaño de los márgenes, etc. No es habitual (y se desaconseja a los usuarios menos expertos) tener que alterar los temas que ggplot2 usa por defecto. Solo se vuelve necesario cuando los gráficos tienen que adecuarse a una imagen corporativa o atenerse a algún criterio de publicación exigente. Un tema es una colección de elementos que indica el color, transparencia, etc. del lienzo sobre el que se representa el gráfico) modificables. El tema que usa ggplot2 por defecto es theme_grey. Al escribir theme_grey() en la consola de R, se muestran alrededor de cuarenta elementos modificables y sus atributos tal y como los define dicho tema. ¿Qué se puede hacer con los temas? Una primera opción es elegir otro. Por ejemplo, se puede reemplazar el habitual por otros disponibles en el paquete como theme_bw (o theme_classic) haciendo p &lt;- p + theme_bw() p Es posible usar tanto los temas que incluye ggplot2 por defecto como otros creados por la comunidad. Algunos, por ejemplo, tratan de imitar el estilo de publicaciones reconocidas como The Economist o similares. Algunos están recogidos en paquetes como, por ejemplo, ggthemes. Finalmente, es posible construir temas propios y personalizados. Aunque no es un proceso complicado, los detalles quedan fuera del alcance de esta introducción. 2.1.5.3 Exportación Una vez creado un gráfico, es posible exportarlo a png, jpg, etc. La función ggsave guarda en un fichero el último gráfico generado con ggplot2. Lo hace, además, en el formato indicado en el nombre del fichero que se quiere generar. Así, ggplot(iris, aes(x = Petal.Length, y = Petal.Width, colour = Species)) + geom_point() ggsave(&quot;mi_grafico.png&quot;) guarda la figura creada en la primera línea en formato png en el fichero mi_grafico.png del directorio de trabajo 2.2 Introducción a ggmap Con ggplot2 se puede también construir representaciones gráficas con información geográfica (puntos, segmentos, etc.): basta con que las estéticas x e y se correspondan con la longitud y la latitud de los datos. Lo que permite hacer ggmap es, en esencia, añadir a los gráficos ya conocidos una capa cartográfica adicional. Para eso usa recursos disponibles en la web a través de APIs (de Google y otros). Un ejemplo sencillo ilustra los usos de ggmap. En primer lugar, se carga (si se ha instalado previamente) el paquete: library(ggmap) Existen varios proveedores que proporcionan APIs de geolocalización. Uno de ellos es Google: dado el nombre más o menos normalizado de un lugar, la API de Google devuelve sus coordenadas. Este servicio tiene una versión gratuita que permite realizar un determinado número de consultas diarias (2500 actualmente); para usos más intensivos, es necesario adquirir una licencia. La función geocode encapsula la consulta a dicha API y devuelve un objeto (un data.frame) que contiene las coordenadas del lugar de interés: #kschool &lt;- geocode(&#39;Calle Magallanes 1, madrid, spain&#39;) kschool&lt;-c(lon=-3.705416,lat= 40.43242) La función get_map consulta otro servicio de información cartográfica (GoogleMaps en el ejemplo siguiente) y descarga un mapa (que es, esencialmente, una imagen raster). mapa &lt;- get_map(location = kschool,zoom = 16,color = &quot;bw&quot;) #mapa&lt;- get_map(location = kschool,zoom = 16, source = &quot;stamen&quot;, maptype = &quot;watercolor&quot;) #mapa&lt;- get_map(location = kschool,zoom = 16, source = &quot;stamen&quot;, maptype = &quot;toner&quot;) Es obvio que para poder invocar las dos funciones anteriores hace falta una conexión a internet. Sin embargo, el resto de las operaciones que se van a realizar se ejecutan localmente. Se puede, por ejemplo, representar el mapa directamente (con la función ggmap): ggmap(mapa) O bien se puede marcar sobre él puntos de interés: require(data.table) # localización de los bares con terrazas de Madrid # https://www.datanalytics.com/2017/03/02/todas-las-terrazas-de-madrid/ terrazas=fread(&quot;data/terrazas.csv&quot;) ggmap(mapa) + geom_point(aes(x = lon, y = lat), data = terrazas, colour = &#39;orange3&#39;,size = 3,alpha=.5) Como puede apreciarse, la sintaxis es similar a la de ggplot2. Una diferencia notables que, ahora, los datos se pasan en la capa, es decir, en este caso, en la función geom_point. 2.2.1 Más ejemplos de mapas con puntos En los ejemplos que siguen se va a utilizar el conjunto de datos crimes que forma parte del paquete ggmap y que incluye información geolocalizada de crímenes cometidos en la ciudad de Houston. En realidad, solo consideraremos los crímenes serios, es decir, crimes.houston &lt;- subset(crime, ! crime$offense %in% c(&quot;auto theft&quot;, &quot;theft&quot;, &quot;burglary&quot;)) El tipo de mapas más simples son los que se limitan a representar puntos sobre una capa cartográfica. #houston&lt;-geocode(&#39;houston&#39;) houston&lt;-c(lon=-95.3698,lat= 29.76043) HoustonMap &lt;- ggmap(get_map(houston, zoom = 14, color = &quot;bw&quot;)) HoustonMap + geom_point(aes(x = lon, y = lat, colour = offense), data = crimes.houston, size = 1) Los mecanismos conocidos de ggplot2, como las facetas, están disponibles en ggmap. Descomponer el anterior gráfico utilizando facet_wrap por tipo de crimen (ver grafico siguiente). Hacer lo mismo con el día de la semana. Pintar las gasolineras en el mapa de España (o de una provincia o un municipio) utilizando el fichero data/carburantes.csv. Modificar el tamaño (o color) de los puntos en función de, por ejemplo, el precio de los carburantes. 2.2.2 Más allá de los puntos: densidades y poligonos Además de geom_point, también están disponibles otros tipos de capas de ggplot2, como stat_bin2d, que cuenta el número de eventos (aqui atracos) que suceden en regiones cuadradas de un tamaño predefinido. Se puede también utilizar stat_density2d, que representa intensidades, para identificar las zonas de mayor criminalidad. HoustonMap + stat_density2d(aes(x = lon, y = lat, alpha = ..level..),fill=&quot;red4&quot;, size = 2, data = subset(crimes.houston,offense==&quot;robbery&quot;), geom = &quot;polygon&quot; ) Por otra parte, la información estadística puede ser proporcionada de manera agregada en unidades espaciales (a nivel provincial, municipal, …), como para los datos del paro. Lo primero que se necesita para representar estar datos, es el conjunto de poligonos (o “shape”) que definen las secciones geograficas. Esta información se puede por ejemplo descargar desde el servidor GADMmediante el paquete raster: require(raster) tmp &lt;- getData(&quot;GADM&quot;, country= &quot;Spain&quot;, level = 2) #mapa administrativo a nivel provincial head(tmp) ## OBJECTID ID_0 ISO NAME_0 ID_1 NAME_1 ID_2 NAME_2 HASC_2 CCN_2 ## 1 1 215 ESP Spain 1 Andalucía 1 Almería ES.AN.AM NA ## 2 2 215 ESP Spain 1 Andalucía 2 Cádiz ES.AN.CD NA ## 3 3 215 ESP Spain 1 Andalucía 3 Córdoba ES.AN.CO NA ## 4 4 215 ESP Spain 1 Andalucía 4 Granada ES.AN.GD NA ## 5 5 215 ESP Spain 1 Andalucía 5 Huelva ES.AN.HL NA ## 6 6 215 ESP Spain 1 Andalucía 6 Jaén ES.AN.JA NA ## CCA_2 TYPE_2 ENGTYPE_2 NL_NAME_2 VARNAME_2 ## 1 04 Provincia Province ## 2 11 Provincia Province ## 3 14 Provincia Province ## 4 18 Provincia Province ## 5 21 Provincia Province ## 6 23 Provincia Province Se puede representar este mapa mediante el comando plot plot(tmp) o utilizando el paquete ggplot2: require(ggplot2) require(maptools) tmp=subset(tmp,!CCA_2==&quot;&quot;) provincias=unionSpatialPolygons(tmp,tmp$CCA_2) #sintetiza el mapa mapa=fortify(provincias) ggplot() + geom_polygon(data = mapa, aes(long, lat, group = group), fill=&quot;grey60&quot;,colour = &quot;grey80&quot;, size = .1) Ahora pintamos en el mapa los datos del paro (Mujeres, 2011, cuatr. I): Paro=subset(paro,Year==2011 &amp; Cuat==&quot;I&quot;) Paro$id=sub(&quot; &quot;,&quot;0&quot;,format(Paro$prov,width=2)) Mapa=merge(mapa,Paro,by=&quot;id&quot;) peninsula=subset(Mapa,!id %in% c(35,38)) #sin canarias ggplot() + geom_polygon(data = peninsula, aes(long, lat, group = group,fill=tasa.paro), colour = &quot;grey80&quot;, size = .1) + facet_grid(~ Genero) + scale_fill_gradient(low=&quot;aliceblue&quot;,high=&quot;steelblue4&quot;) Podemos incluso dibjar este mapa, sobre un lienzo obtenido mediante get_map: require(ggmap) centro &lt;- c(lon=-3.70379,lat= 40.41678) #geocode(&quot;Madrid, Spain&quot;) mapa &lt;- get_map(centro, zoom = 6,maptype=&quot;toner-lite&quot;,source=&quot;stamen&quot;) mujeres=subset(Mapa,Genero=&quot;Mujeres&quot;) ggmap(mapa) + geom_polygon(data = mujeres, aes(long, lat, group = group,fill=tasa.paro),alpha=.5) + scale_fill_gradient(low=&quot;aliceblue&quot;,high=&quot;steelblue4&quot;) 2.3 Extensión dinamica de los graficos Existen varios paquetes que permiten una visualización dinamica de los graficos. Aqui veremos brevemente dos de ellos : ‘plotly’ y ‘leaflet’. El primero permite con una unica función (ggplotly()) convertir un gráfico elaborado con ggplot en un gráfico donde los ejes, el zoom, las etiquetas, etc., pueden ser modificados con el ratón: require(plotly) p&lt;-ggplot(paro, aes(x = Year, y = tasa.paro, color=Genero,label=Provincias)) + geom_jitter(alpha=.1) + geom_smooth(se=FALSE) ggplotly(p,tooltip = c(&quot;label&quot;, &quot;color&quot;)) Con leafletse puede cambiar la resolución del lienzo: require(leaflet) DT&lt;-data.frame(id=names(provincias),row.names=names(provincias)) espana&lt;-SpatialPolygonsDataFrame(provincias,DT) espana@data=merge(espana@data,subset(Paro,Genero==&quot;Mujeres&quot;),by=&quot;id&quot;) rownames(espana@data)&lt;-espana$id bins &lt;- quantile(espana$tasa.paro,seq(0,1,.2)) pal &lt;- colorBin(&quot;YlOrRd&quot;, domain = espana$tasa.paro , bins = bins) #escala de colores espana$color&lt;-pal(espana$tasa.paro) leaflet(data=espana)%&gt;% addProviderTiles(&quot;CartoDB.Positron&quot;) %&gt;% addPolygons(fillOpacity = 0.5, fillColor = ~color,color = &quot;white&quot;,weight = 1,dashArray = &quot;3&quot;) %&gt;% addLegend(pal = pal, values = ~tasa.paro, opacity = 0.7, title = &quot;tasa de paro&quot;, position = &quot;bottomright&quot;,labFormat = labelFormat(digits=2)) "],
["rmarkdown-y-shiny.html", "3 Rmarkdown y shiny 3.1 Rmarkdown 3.2 Shiny", " 3 Rmarkdown y shiny Esta sección está dedicada a dos extensiones de R: shiny y rmarkdown. El primero de ellos permite crear cuadros de mando interactivos. El segundo, documentos automatizados que combinan texto con código, tablas y gráficos generados directamente por R. Estos dos paquetes no son complejos sino, más bien, extensos y llenos de detalles. El objetivo de esta sesión es recorrer sus posibilidades. 3.1 Rmarkdown Rmarkdown permite generar documentos dinámicos al mezclar texto formateado y resultados generados R. Los documentos generados pueden estar en HTML, PDF, Word y muchos otros formatos. Las ventajas de esta herramienta son numerosas: El código y sus resultados no están separados de los comentarios asociados a ellos El documento final es reproducible El documento se puede actualizar fácilmente, por ejemplo, si los datos de origen se han modificado. Por lo tanto, es una herramienta muy práctica para exportar, comunicar y difundir resultados estadísticos. Este documento se ha generado a partir de archivos R Markdown ^ [Más precisamente gracias a la extensión bookdown que permite generar documentos de tipo libro]. Aprender Rmarkdown implica aprender dos cosas distintas: Markdown, un formato para escribir documentos simples en modo texto. Tiene la ventaja de ser fácilmente legible por humanos pero, a la vez, procesable programáticamente para volcarlos en otros formatos: pdf, html, etc. La integración entre R y markdown Para aprender markdown, una tarea que no debería durar más de 10-15 minutos, se recomiendan los dos siguientes ejercicios. Crea un fichero .Rmd usando File &gt; New File &gt; R Markdown. Al crear un nuevo fichero de tipo R Markdown, RStudio proporciona, en lugar de uno vacío, una plantilla que muestra algunas de las opciones disponibles en este formato. Eso facilita el siguiente ejercicio: Aprende markdown modificando el fichero de ejemplo creado en el ejercicio anterior añadiéndole títulos de varios niveles, párrafos de texto, cursivas, negritas, enlaces, listas (numeradas y sin numerar), etc. usando como guía el Cheat Sheet del paquete. Recuerda compilar el documento (p.e., pulsando el botón con la etiqueta Knit HTML situado encima del panel de edición de RStudio) para inspeccionar el resultado final. Tambiénse pueden generar documentos en formato Word y PDF. Para estos tendrás que tener instalados los programas necesarios: MS Word, LibreOffice o similar para el primero y LaTeX para el segundo. El segundo de los componentes de Rmarkdown (y lo que lo diferencia de Markdown a secas) es la posibilidad de incorporar bloques de código en el hilo del documento. Estos bloques de código se procesan durante la compilación del documento y los resultados que generan (tablas, gráficos, etc.) se integran en la salida. La plantilla de fichero Rmarkdown que genera RStudio incluye unos cuantos ejemplos de bloques de código. Inserta sobre tu documento (o sobre una nueva plantilla) bloques de código de R que hagan alguna cosa. Los bloques de código incluyen opciones en su encabezamiento (p.e., para que un bloque se ejecute o no; para que el código se muestre o se oculte en el documento final, etc.). Las opciones disponibles se pueden consultar en el Cheat Sheet del paquete. Con Rmarkdown y sus extensiones se han escrito informes, artículos e, incluso, libros completos. Una de las grandes ventajas de integrar el texto y el código es que todo el proceso de generación del documento final es automático, sin necesidad de incorporar manualmente gráficos o tablas procedentes de terceros programas. Una consecuencia de creciente interés de la automatización del proceso es que evita los errores humanos (o cierto tipo de ellos) en la manipulación de datos. El documento, al contener el código, es en sí mismo la traza de las manipulaciones realizadas y un tercero, en caso de duda, puede reproducirse. 3.2 Shiny shiny es un paquete de R para la construcción de cuadros de mando web interactivos. Permite, por ejemplo, crear interfaces para algoritmos o acceder y manipular tablas de datos a través de controles de HMTL: sliders, botones, etc. El paquete proporciona varias aplicaciones de ejemplo que usaremos para aprender los rudimentos de shiny. Por ejemplo, se puede hacer library(shiny) runExample(example = &quot;01_hello&quot;) para desplegar la aplicación de ejemplo 01_hello. Esta aplicación pinta en el panel central un histograma y tiene en el lateral un slider con el que modular su granularidad (técnicamente, para definir el número de pedazos, breaks, en los que partir el rango de valores del vector subyacente). Para detener la aplicación, en RStudio, presiona sobre el icono de la señal de stop (en la parte superior de la ventana de la consola); en una terminal, usa Control-C para interrumpir la ejecución. Ejecuta runExample() (sin argumento); el mensaje de error indica qué otros ejemplos además de 01_hello están disponibles por defecto. Échales un vistazo a algunos. Crea tu primera aplicación en shiny. Para ello, despliega 01_hello. Luego, copia los ficheros ui.r y server.r en un nuevo directorio vacío. Llámalo, por ejemplo, prueba00. Luego ejecuta runApp(“prueba00”) para desplegarla. (Nota: el argumento de runApp tiene que ser la ruta, sea absoluta o relativa, del directorio en cuestión; recuerda que una aplicación en shiny recibe el nombre del directorio que la contiene). El ejercicio anterior muestra cómo construir aplicaciones en shiny. Una aplicación en shiny es un directorio quee da nombre a la aplicación. Dentro de él tiene que haber, como mínimo, dos ficheros: ui.r y server.r. El primero define la interfaz de la aplicación. El segundo realiza los cálculos en segundo plano cada vez que el usuario manipula los controles de la interfaz. Además de estos ficheros, en aplicaciones más complejas, puede haber otros organizados o no en subdirectorios: datos, otros ficheros auxiliares de código, logos, CSSs, imágenes estáticas, etc. Tendrás que leer la documentación de shiny para averiguar cómo y dónde colocar estos recursos adicionales. ui.r y server.r se comunican entre sí: ui.r tiene que pasarle parámetros a server.r y este resultados a aquel. Esto se hace a través de variables y estructuras de datos con una forma muy particular. El siguiente ejercicio está pensado para que descubras el mecanismo de comunicación. Se te va a pedir que traduzcas el nombre de las variables y los parámetros al español. Obviamente, al traducir las variables en uno de los ficheros se romperá la aplicación. Realinear los nombres en el otro fichero te servirá para identificar los mecanismos de comunicación. Crea prueba01 como una copia de prueba00. Entonces, traduce al español el nombre de todas las variables implicadas en la aplicación. El siguiente ejercicio te enseñará a modificar la interfaz de una aplicación en shiny, incorporar nuevos controles y añadir el código subyacente para que responda adecuadamente. Añade a la aplicación prueba01 otro slider que mueva una linea vertical roja que dibujes sobre el histograma. Es recomendable que comiences, y en este orden, añadiendo una línea roja en algún punto (del eje x) prefijado con la función abline, incorporando el slider y finalmente, vinculando el valor proporcionado por el slider al punto del eje x. Nota: cuando modifiques ui.r, presta atención a la estructura del programa y cómo se corresponde a la de la interfaz web: qué es lo que va en la barra lateral, qué en el panel central, etc. Ten cuidado además con los paréntesis: ¡hay muchos y es fácil desemparejarlos! Inspecciona el tutorial de shiny (http://shiny.rstudio.com/tutorial/) para descubrir qué tipo widgets (además de sliders) existen, cómo se procesan esos inputs en server.r, etc. Recuerda que ese tutorial es la principal fuente de información sobre todo lo relacionado con shiny. Visita la galería de aplicaciones de shiny (http://shiny.rstudio.com/gallery/) para investigar cómo implementar controles, qué tipos adicionales de paneles existen, etc. Uno de los asuntos (avanzados) que se discuten en esas páginas es el de las reacciones: shiny está basado en un tipo de programación denominada reactiva, que es la que permite que las funciones de server.r simulen estar escuchando (y reaccionen) a los cambios que realiza el usuario en los controles de la aplicación. Puedes buscar en internet más información sobre la programación reactiva si te interesa el tema. "],
["referencias.html", "4 Referencias", " 4 Referencias Este curso está basado en el siguiente libro : R para profesionales de los datos, Carlos Bellosta, 2017, https://datanalytics.com/libro_r Y también muy inspirado de estos otros libros: Data Visualisation with R, Thomas Rahlf, 2014, http://www.datavisualisation-r.com/ R Graph Cookbook , Hrishi Mittal, 2011 "]
]
